/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Grammar.jj */
/*@egen*/PARSER_BEGIN(PatinaParser)

package parser;

import java.io.StringReader;
import java.io.Reader;
import java.util.LinkedList;

public class PatinaParser/*@bgen(jjtree)*/implements PatinaParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTPatinaParserState jjtree = new JJTPatinaParserState();

/*@egen*/
}
PARSER_END(PatinaParser)

/* Special tokens are ignored by the parser, but can still be recovered during parsing if necessary. */
SPECIAL_TOKEN :
{
    < WHITESPACE : (["\n", "\r", "\t", " "])+ >
|   < SINGLE_LINE_COMMENT : "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}

TOKEN : /* KEYWORDS */
{
    < BE : "be" >
|   < FALSE : "false" >
|   < FN : "fn" >
|   < IF: "if" >
|   < LET : "let" >
|   < MUT : "mut" >
|   < RETURN : "return" >
|   < SET: "set" >
|   < TRUE : "true" >
|   < WHILE : "while" >
}

TOKEN : /* SYMBOLS */
{
    < LARROW : "<-" >
|   < RARROW : "->" >

|   < LPAR : "(" >
|   < RPAR : ")" >
|   < LCBR : "{" >
|   < RCBR : "}" >
|   < LSBR : "[" >
|   < RSBR : "]" >
|   < LABR : "<" >
|   < RABR : ">" >

|   < COLON : ":" >
|   < COMMA : "," >
|   < PERIOD : "." >

|   < PLUS : "+" >
|   < MINUS : "-" >
|   < MULT : "*" >
|   < DIV : "/" >
|   < MOD : "%" >

|   < AMP : "&" >
|   < CARET : "^" >
|   < EXCLAMATION : "!" >
|   < PIPE : "|" >
|   < SHIFTL : "<<" >
|   < SHIFTR : ">>" >

|   < EQ : "=" >
|   < LEQ : "<=" >
|   < GEQ : ">=" >
|   < NEQ : "!=" >
}

TOKEN : /* IDENTIFIERS */
{
    < IDENTIFIER : <LETTER> (<LETTER>|<DIGIT>)* >
|   < #LETTER : ["_","a"-"z","A"-"Z"] >
|   < #DIGIT : ["0"-"9"] >
}

TOKEN : /* LITERALS */
{
        < INTEGER_LITERAL :  (<DIGIT>)+ >
   |    < FLOATING_LITERAL : <INTEGER_LITERAL> "." <INTEGER_LITERAL> >
}

void BooleanLiteral() :
{/*@bgen(jjtree) BooleanLiteral */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLEANLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BooleanLiteral */
    try {
/*@egen*/
    <TRUE>
|   <FALSE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* Top-level production */
LinkedList<TypeCheckable> Input() :
{/*@bgen(jjtree) Input */
    SimpleNode jjtn000 = new SimpleNode(JJTINPUT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Statement s;
    LinkedList<TypeCheckable> result = new LinkedList<TypeCheckable>();
}
{/*@bgen(jjtree) Input */
    try {
/*@egen*/
    (Statement())+ <EOF>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Statement() :
{/*@bgen(jjtree) Statement */
    SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Assignment a;
    Declaration d;
    IExpression e;
}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    (Expression() | Assignment()) <PERIOD>
    (
          LOOKAHEAD(3)
                    d = Declaration() <PERIOD> { result.add(d); }
                |   a = Assignment()  <PERIOD> { result.add(a); }
                |   e = Expression()  <PERIOD> { result.add(e); }
        )+
        <EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        { return result; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IExpression Expression() :
{/*@bgen(jjtree) Expression */
    SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IExpression result, b;
}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    result = UnaryExpression()
    (
        (<PLUS> | <MINUS> | <MULT> | <DIV> | <MOD>)
        b = UnaryExpression()
        { result = new Mult(result, b); }
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return result; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Declaration() :
{/*@bgen(jjtree) Declaration */
  SimpleNode jjtn000 = new SimpleNode(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declaration */
    try {
/*@egen*/
    ImmutableDeclaration()
|   MutableDeclaration()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ImmutableDeclaration() :
{/*@bgen(jjtree) ImmutableDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTIMMUTABLEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ImmutableDeclaration */
    try {
/*@egen*/
    <LET> <IDENTIFIER> <BE> Type() <LARROW> Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MutableDeclaration() :
{/*@bgen(jjtree) MutableDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTMUTABLEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MutableDeclaration */
    try {
/*@egen*/
    <LET> <IDENTIFIER> <BE> Type() <MUT> (<LARROW> Expression())?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Assignment() :
{/*@bgen(jjtree) Assignment */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assignment */
    try {
/*@egen*/
    <SET> <IDENTIFIER> <LARROW> Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*void FunctionDeclaration() :
{}
{
    <LET> <IDENTIFIER>
}*/

void UnaryExpression() :
{/*@bgen(jjtree) UnaryExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnaryExpression */
    try {
/*@egen*/
    <INTEGER_LITERAL>
|   <FLOATING_LITERAL>
|   <IDENTIFIER>
|   BooleanLiteral()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Type() :
{/*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    <IDENTIFIER>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}